XAUUSD TRADING BOT - COMPLETE PARALLEL IMPROVEMENTS PROMPT (1-8)
================================================================================

IMPROVEMENT 1: SMART POSITION SIZING DENGAN VOLATILITAS ADAPTER
File: bot/strategy.py, bot/risk_manager.py
Task:
1. Di strategy.py, tambahkan method: calculate_dynamic_lot_size(indicators, base_lot_size)
   - Input: indicators dict dengan 'atr' dan 'close'
   - Tentukan ATR zone: EXTREME_LOW (<0.005%), LOW, NORMAL, HIGH, EXTREME_HIGH (>0.1%)
   - Formula: base_lot_size * volatility_multiplier
   - EXTREME_LOW ATR = 0.5x (kurangi saat market quiet)
   - NORMAL = 1.0x (standard)
   - EXTREME_HIGH = 0.7x (kurangi saat volatile)
   - Return: (adjusted_lot_size, volatility_zone, multiplier)
   - Log: "Dynamic LOT ADJUSTMENT: Zone={zone}, base={base}x{mult} = {result}"
2. Di risk_manager.py, integrate calculate_dynamic_lot_size ke calculate_dynamic_lot()
   - Jika user_id ada, cek ATR dari indicators sebelum hitung lot
   - Jika ATR available, apply multiplier
   - Tetap maintain MIN_LOT_SIZE (0.01) dan MAX_LOT_SIZE (0.1)
3. Return value dari detect_signal sekarang include: position_size, volatility_zone, lot_multiplier
Graceful Fallback: Jika ATR tidak tersedia, gunakan 1.0x multiplier (normal)
Non-Blocking: Signal tetap di-generate, hanya adjust ukuran posisi

================================================================================

IMPROVEMENT 2: TRADE SETUP VALIDATION DENGAN PATTERN RECOGNITION
File: bot/indicators.py, bot/strategy.py
Task:
1. Di indicators.py, tambahkan 3 methods:
   a) detect_inside_bar(df, lookback=5):
      - Current candle HIGH < prev HIGH AND Current LOW > prev LOW
      - Return: {is_inside_bar: bool, prev_high: float, prev_low: float, body_ratio: float}
   b) detect_pin_bar(df, lookback=20):
      - Pin Bar BUY: lower_shadow >= 2x body_size, bearish close, next_candle_open > pin_high
      - Pin Bar SELL: upper_shadow >= 2x body_size, bullish close, next_candle_open < pin_low
      - Return: {is_pin_bar: bool, pin_type: 'BUY'/'SELL'/None, shadow_ratio: float, confidence: float}
   c) detect_reversal_patterns(df, lookback=50):
      - Cek: double bottom, double top, head & shoulders (simplified)
      - Return: {pattern_found: bool, pattern_name: str, reversal_type: 'BUY'/'SELL', confidence: float}
2. Di strategy.py, update detect_signal return value:
   - Tambah: pattern_name, pattern_confidence (10-20% boost jika pattern match)
   - Jika pattern match dengan signal direction, confidence += 15%
   - Log: "Pattern detected: {pattern_name} (confidence +{boost}%)"
3. Signal confidence_multiplier:
   - Normal signal confidence = 1.0
   - + Inside Bar match = +0.10
   - + Pin Bar match = +0.15
   - + Reversal pattern = +0.20
   - Max boost = 0.35 (atau 35% increase)
Graceful Fallback: Pattern tidak tersedia → confidence = 1.0 (normal), signal tetap di-generate
Non-Blocking: Enhancement saja, signal tetap unlimited

================================================================================

IMPROVEMENT 3: INTRADAY SESSION OPTIMIZATION
File: bot/strategy.py
Task:
1. Di strategy.py, tambahkan method: analyze_session_strength(current_time_utc):
   - Define session times UTC:
     * Asia: 00:00-08:00
     * London: 07:00-16:00
     * New York: 13:00-22:00
   - Calculate strength:
     * London + NY overlap (13:00-16:00): STRONGEST liquidity, return 1.2x confidence
     * Single session active: MEDIUM liquidity, return 0.95x confidence
     * Off-market (22:00-00:00): OFF-MARKET, return 0.8x confidence
   - Return: {session_name: str, session_strength: 'STRONGEST'/'MEDIUM'/'OFF-MARKET', confidence_multiplier: float, log_info: str}
2. Integrate ke detect_signal:
   - Call analyze_session_strength pada setiap signal generation
   - Apply confidence_multiplier ke final signal confidence
   - Log: "Trading di {session_name} ({strength} liquidity, {mult}x confidence)"
3. Signal tetap unlimited, hanya apply confidence multiplier berdasarkan session
Graceful Fallback: Jika timezone conversion error, gunakan 0.95x multiplier
Non-Blocking: Session hanya untuk confidence adjustment, tidak block signal

================================================================================

IMPROVEMENT 4: WIN RATE TRACKING PER SIGNAL TYPE
File: bot/database.py, bot/telegram_bot.py, bot/strategy.py
Task:
1. Di database.py, tambahkan SQLAlchemy table baru: SignalPerformance
   Columns:
   - id (Integer, PK)
   - signal_id (Integer, FK to Trade)
   - signal_type (String): 'BUY' atau 'SELL'
   - entry_price (Float)
   - exit_price (Float, nullable)
   - pnl (Float, nullable)
   - result (String): 'WIN', 'LOSS', 'BREAK_EVEN', 'OPEN'
   - pattern_used (String, nullable): 'INSIDE_BAR', 'PIN_BAR', 'DIVERGENCE', dll
   - session_time (String): 'ASIA', 'LONDON', 'NEW_YORK', 'OVERLAP'
   - volatility_zone (String): 'EXTREME_LOW', 'LOW', 'NORMAL', 'HIGH', 'EXTREME_HIGH'
   - mtf_score (Float): multi-timeframe alignment score
   - entry_timestamp (DateTime)
   - exit_timestamp (DateTime, nullable)
   - duration (Integer, nullable): seconds dari entry ke exit
2. Di strategy.py, saat generate signal:
   - Capture: signal_type, entry_price, pattern_name, session_name, volatility_zone, mtf_score
   - Pass ke telegram_bot untuk later tracking
3. Di telegram_bot.py, saat trade ditutup:
   - Update SignalPerformance: exit_price, pnl, result, exit_timestamp, duration
   - Calculate win_rate per kategori:
     * "Inside Bar patterns: X wins, Y losses, Z% win rate (N trades)"
     * "London session: X% win rate"
     * "Volatile market: X% win rate"
   - Display stats di dashboard: top 3 best performing patterns
   - Use data untuk future optimization (boost high win-rate patterns)
Graceful Fallback: Jika pattern/session data missing, track sebagai 'GENERIC' category
Non-Blocking: Tracking saja, tidak affect signal generation

================================================================================

IMPROVEMENT 5: ADVANCED MOMENTUM CONFIRMATION DENGAN EMA RIBBON
File: bot/indicators.py, bot/strategy.py
Task:
1. Di indicators.py, implement EMA Ribbon method: calculate_ema_ribbon(df, periods=[5,10,15,20,25,30]):
   - Calculate 6 EMAs dengan periods [5, 10, 15, 20, 25, 30]
   - Return: {ema_5: series, ema_10: series, ..., ema_30: series, alignment_status: str, description: str}
2. Di strategy.py, tambahkan method: check_ema_ribbon_alignment(indicators, signal_type):
   - Ribbon BULLISH: EMA5 > EMA10 > EMA15 > EMA20 > EMA25 > EMA30 (fully stacked)
   - Ribbon BEARISH: EMA5 < EMA10 < EMA15 < EMA20 < EMA25 < EMA30 (fully stacked)
   - Ribbon MIXED: no clear order (weak momentum)
   - Return: {alignment_status: 'STRONG_BULLISH'/'BULLISH'/'NEUTRAL'/'BEARISH'/'STRONG_BEARISH', confidence_modifier: float, details: str}
3. Confidence modifier:
   - STRONG BULLISH + BUY signal = +15% confidence
   - BULLISH + BUY signal = +10% confidence
   - NEUTRAL = +0% (no boost)
   - MIXED = -10% confidence
   - STRONG BEARISH + BUY signal = block atau -30% confidence
4. Integrate ke detect_signal:
   - Check ribbon alignment sebelum final confidence calculation
   - Apply confidence modifier
   - Log: "EMA Ribbon: {status}, confidence {+/-}X%"
Graceful Fallback: Jika EMA data incomplete, alignment_status = 'NEUTRAL', modifier = 0.0
Non-Blocking: Enhancement saja, signal tetap unlimited

================================================================================

IMPROVEMENT 6: BREAKOUT CONFIRMATION DENGAN PREVIOUS BARS REFERENCE
File: bot/strategy.py, bot/indicators.py
Task:
1. Di strategy.py, maintain history: previous_50_bars_high dan previous_50_bars_low (dari last 50 candles)
   - Keep rolling window size = 50
   - Update setiap candle close
2. Tambahkan method: calculate_breakout_strength(signal_type, current_close, current_atr):
   - BUY breakout: check apakah current_close > max(previous_20_bars_high)
   - SELL breakout: check apakah current_close < min(previous_20_bars_low)
   - Calculate breakout_level dan breakout_magnitude:
     * BUY: breakout_magnitude = (current_close - max_high_20) / current_atr
     * SELL: breakout_magnitude = (min_low_20 - current_close) / current_atr
   - Confidence adjustment:
     * breakout_magnitude > 1.5 ATR: STRONG breakout, +20% confidence
     * breakout_magnitude 0.5-1.5 ATR: NORMAL breakout, +0% confidence
     * breakout_magnitude < 0.5 ATR: WEAK breakout, -15% confidence
   - Return: {is_breakout: bool, breakout_strength: str, magnitude: float, confidence_adjustment: float}
3. Integrate ke detect_signal:
   - Check breakout confirmation untuk setiap signal
   - Apply confidence adjustment
   - Log: "Breakout confirmation: {strength} (magnitude {mag:.2f}x ATR), confidence {adj:+.0%}"
4. Signal tetap unlimited, hanya adjust confidence berdasarkan breakout strength
Graceful Fallback: Jika history < 20 bars, assume NORMAL breakout (confidence +0%)
Non-Blocking: Confirmation saja, signal tetap generate

================================================================================

IMPROVEMENT 7: DRAWDOWN PROTECTION DENGAN DYNAMIC SL EXPANSION
File: bot/strategy.py, bot/risk_manager.py
Task:
1. Di risk_manager.py, tambahkan method: calculate_dynamic_sl_expansion(daily_drawdown_percent):
   - daily_drawdown_percent = current_daily_loss / account_balance * 100
   - If drawdown < 20%: SL multiplier = 1.0 (normal SL)
   - If drawdown 20-40%: SL multiplier = 1.15 (expand SL +15% untuk capture full moves)
   - If drawdown > 40%: SL multiplier = 1.30 (expand SL +30% untuk recovery mode)
   - Return: {drawdown_percent: float, sl_multiplier: float, mode: 'NORMAL'/'EXPANSION'/'RECOVERY', log_info: str}
2. Di strategy.py, saat calculate_sl_tp():
   - Get daily_drawdown dari risk_manager
   - Get sl_multiplier dari calculate_dynamic_sl_expansion()
   - Apply: adjusted_sl = base_sl * sl_multiplier
   - Log: "Drawdown mode: {mode} (drawdown {drawdown}%), SL expanded {mult}x"
3. Alternate strategy untuk drawdown > 40%:
   - Option 1: Expand SL +30% (current)
   - Option 2: Reduce lot_size by 50% (conservative)
   - Choose option berdasarkan config, log pilihan yang dipakai
4. Signal tetap unlimited, hanya adjust SL berdasarkan drawdown level
Graceful Fallback: Jika daily_drawdown data unavailable, gunakan 1.0x multiplier (normal)
Non-Blocking: SL adjustment saja, signal tetap generate

================================================================================

IMPROVEMENT 8: CORRELATION CHECK DENGAN MULTIPLE TIMEFRAMES
File: bot/strategy.py
Task:
1. Expand dari existing M1+M5+H1 check, tambah 4H dan Daily timeframe
2. Tambahkan method: check_multiple_timeframe_correlation(m1_ind, m5_ind, h1_ind, m4h_ind, daily_ind, signal_type):
   - Check EMA alignment untuk setiap timeframe
   - M1: EMA5 > EMA20 = bullish
   - M5: EMA5 > EMA20 = bullish
   - H1: EMA5 > EMA20 = bullish
   - 4H: EMA5 > EMA20 = bullish
   - Daily: EMA10 > EMA50 = bullish (gunakan longer periods untuk daily)
   - Scoring:
     * All 5 TF aligned: 100% high confidence, 1.3x multiplier
     * 4 TF aligned: 90% confidence, 1.2x multiplier
     * 3 TF aligned (M1+M5+H1): 70% confidence, 1.0x multiplier
     * 2 TF aligned: 50% confidence, 0.8x multiplier
     * 1 TF aligned: 30% confidence, 0.6x multiplier
   - Return: {timeframes_aligned: int, total_timeframes: int, confidence_multiplier: float, alignment_details: {m1: bool, m5: bool, h1: bool, m4h: bool, daily: bool}, log_info: str}
3. Integrate ke detect_signal:
   - Fetch 4H dan Daily data (graceful fallback jika tidak tersedia)
   - Call check_multiple_timeframe_correlation()
   - Apply confidence_multiplier
   - Log: "MTF Correlation: {N}/{total} TF aligned, confidence {mult}x"
4. Signal tetap unlimited tetapi dengan confidence multiplier berdasarkan TF alignment
Graceful Fallback: Jika 4H/Daily data unavailable, tetap hitung dengan available TF saja (M1/M5/H1)
Non-Blocking: Correlation check saja, signal tetap generate meski hanya M1 aligned

================================================================================

RINGKASAN IMPLEMENTASI PARALEL

PRIORITAS EKSEKUSI (bisa dikerjakan bersamaan):

BATCH 1 (NO DEPENDENCY):
- Improvement 1: Smart Position Sizing (calculate_dynamic_lot_size)
- Improvement 5: EMA Ribbon (calculate_ema_ribbon)
- Improvement 7: Drawdown Protection (dynamic_sl_expansion)

BATCH 2 (SETELAH BATCH 1):
- Improvement 2: Pattern Recognition (detect_inside_bar, detect_pin_bar)
- Improvement 6: Breakout Confirmation (calculate_breakout_strength)
- Improvement 8: Multiple TF Correlation (check_multiple_timeframe_correlation)

BATCH 3 (SETELAH BATCH 2):
- Improvement 3: Session Optimization (analyze_session_strength)
- Improvement 4: Win Rate Tracking (SignalPerformance table + tracking)

================================================================================

KEY PRINCIPLES:
✅ Signal TETAP UNLIMITED - tidak ada blocking, hanya confidence adjustment
✅ GRACEFUL FALLBACK untuk semua undefined/missing data
✅ Semua improvement adalah ENHANCEMENT non-blocking
✅ Log yang detail untuk transparency
✅ Integrate ke detect_signal secara bertahap
✅ Database updates untuk post-analysis dan optimization
✅ NO BREAKING CHANGES

HASIL AKHIR:
- 8 improvements selesai, signal unlimited, enhanced quality, better risk management
- Win rate tracking untuk continuous improvement
- Dynamic position sizing & SL berdasarkan market conditions
- Pattern recognition & multi-timeframe validation
- Session optimization untuk trading yang lebih profitable

================================================================================
